<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="LeonardoEzio">
  <!-- Open Graph Data -->
  <meta property="og:title" content="时间复杂度与空间复杂度">
  <meta property="og:description" content="一个不那么厉害的程序员">
  <meta property="og:site_name" content="LeonardoEzio">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://LeonardoEzio.github.io">
  
    <link rel="alternate" href="/atom.xml" title="LeonardoEzio" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>LeonardoEzio</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">时间复杂度与空间复杂度</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  首页
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  归档
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/LeonardoEzio">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:LeonardoEzio@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By LeonardoEzio</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-03-17</span>
            <span class="time">10:25:20</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/数据结构与算法/">数据结构与算法</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/算法/">#算法</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><blockquote>
<p>执行效率是考量一个算法是否高效的主要指标。然而时间、空间复杂度又是衡量算法执行效率的主要维度</p>
</blockquote>
<h5 id="一、事后统计法的局限"><a href="#一、事后统计法的局限" class="headerlink" title="一、事后统计法的局限"></a>一、事后统计法的局限</h5><blockquote>
<p>以前通过统计、监控实际代码的运行就能够获取算法执行的时间和占用的内存大小。这种事后统计方法虽然能够评估算法的执行效率，但还是存在诸多缺陷。</p>
</blockquote>
<ol>
<li><p>测试结果非常依赖测试环境</p>
<p>测试环境中硬件配置的不同对测试结果会产生很大的影响。</p>
</li>
<li><p>测试结果受数据规模的影响较大</p>
<p>对于同一个算法而言，测试数据量的大小不同，其所得出的性能测试结果也会不同。</p>
</li>
</ol>
<h5 id="二、大-O复杂度表示法"><a href="#二、大-O复杂度表示法" class="headerlink" title="二、大 O复杂度表示法"></a>二、大 O复杂度表示法</h5><p>如下一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="number">1</span>   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">     <span class="number">2</span>   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;　i&lt;n ; i++)&#123;</span><br><span class="line">     <span class="number">3</span>       sum = sum +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>假设每一段代码的执行时间单位为Ｔ，那么第１行代码执行时间为Ｔ，第３行代码由于执行了ｎ次，那么执行时间为ｎＴ所以这段代码的总执行时间为（ｎ＋１）Ｔ，由此可知：所有代码的执行时间T(n)与每行代码的执行次数n成正比。</p>
<p>接下来再看一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="number">1</span>   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">     <span class="number">2</span>   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;= n ; ++i)&#123;</span><br><span class="line">     <span class="number">3</span>       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;= n ; ++j)&#123;</span><br><span class="line">     <span class="number">4</span>           sum = sum + i*j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里每行代码的执行时间单位仍旧为T，那么第1行代码的执行时间为T，第4行代码由于执行了n<sup>2</sup>次，所以执行时间为n<sup>2</sup>T。因此，整段代码的执行时间为：（n<sup>2</sup>+1）T 。</p>
<p>将以上规律总结成一个公式，就是我们所知的<strong>大O表达式</strong>。</p>
<blockquote>
<p>T(n) = O ( f (n) )</p>
</blockquote>
<p>其中：T(n)代表代码所执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。而公式中的O则表明了代码的执行时间T(n)与 f(n) 表达式成正比。</p>
<p>大O复杂度分析表示法，并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，一般叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity)，简称<strong>时间复杂度</strong>。同时，当n趋于无限大的时候，我们就可以忽略公式中的低阶、常量、与系数三部分。只需记录一个最大的量级，如 T(n) = O(2n<sup>2</sup> + 2n +3) 我们省略掉其中的低阶、常量、与系数所得出的最终结果为：T(n) = O(n<sup>2</sup>)。因此以上两段代码的时间复杂度就可以记为 ： T(n) = O(n) ；T(n) = O(n<sup>2</sup>)。</p>
<p><strong>三、时间复杂度分析</strong></p>
<ol>
<li><p>只关注循环执行次数最多的一段代码：</p>
<p>关于这一点，之前的代码示列就是很好的说明，这里不再赘述。</p>
</li>
<li><p>加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
<p>比如如下一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sumOne = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span> ; ++i)&#123;</span><br><span class="line">   <span class="number">1</span>         sumOne += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sumTwo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n ; ++i)&#123;</span><br><span class="line">    <span class="number">2</span>        sumTwo += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sumThree = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n ; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ;++j)&#123;</span><br><span class="line">    <span class="number">3</span>            sumThree = sumThree + i *j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sumOne + sumTwo + sumThree;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码共分为三个部分，分别求sumOne、sumTwo、sumThree。我们可以分别解析每一个部分的时间复杂度，然后再从他们之中选取一个量级最大的作为整段代码的复杂度。</p>
</li>
</ol>
<p>   第一段代码执行了1000次，所以其代表的是一个常量级的执行时间，跟n的规模无关，可以将其忽略掉。</p>
<p>   第二段代码和第三段代码分别执行了 n 次和 n<sup>2</sup>次，所以他们的时间复杂度分别为O(n) 和O(n<sup>2</sup>)。</p>
<p>   综合这三段代码的时间复杂度，我们取其中最大的量级，那么整段代码的复杂度就为：O(n<sup>2</sup>)</p>
<p>   因此将上述这个公式抽象一下就可以得出：</p>
<blockquote>
<p>如果：T1(n) = O(f(n))，T2(n)=O(g(n))；那么 T(n) = T1(n)+T2(n) = max(O(f(n)),O(g(n)))=O(max(f(n),g(n)))</p>
</blockquote>
<ol start="3">
<li><p>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
<blockquote>
<p>如果T1(n) = O(f(n))，T2(n) = O(g(n))；那么 T(n) = T1(n) x T2(n) = O(f(n)) x O(g(n) = O(f(n) x g(n))</p>
</blockquote>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ;++i)&#123;</span><br><span class="line">   <span class="number">1</span>         result = result + subSum(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> subSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++j)&#123;</span><br><span class="line">    <span class="number">2</span>        subSum += j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> subSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>   其中：第一段，第二段代码都是执行了n次，时间复杂度都是 T(n) = O(n)。但由于第二段代码是嵌套在第一段代码之中执行的，因此整个代码的时间复杂度应为：T(n) = T1(n) x T2(n) = O(n) x O(n) = O(n<sup>2</sup>)</p>
<p><strong>四、常见时间复杂度</strong></p>
<p>​    </p>
<table>
<thead>
<tr>
<th style="text-align:center">多项式量级</th>
<th style="text-align:center">非多项式量级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">常量阶O(1)</td>
<td style="text-align:center">指数阶O(2<sup>n</sup>)</td>
</tr>
<tr>
<td style="text-align:center">对数阶O(logn)</td>
<td style="text-align:center">阶乘阶O(n!)</td>
</tr>
<tr>
<td style="text-align:center">线性阶O(n)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">线性对数阶O(nlogn)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">平方阶O(n<sup>2</sup>)、立方阶O(n<sup>3</sup>)、··· 、k次方阶O(n<sup>k</sup>)</td>
</tr>
</tbody>
</table>
<ol>
<li><p><strong>常量阶 O(1)</strong></p>
<p>一般来说，只要算法中不存在循环语句、递归语句、即使有成千上万行代码，其时间复杂度仍旧是O(1)</p>
</li>
</ol>
<ol start="2">
<li><p><strong>对数阶O(logn)，线性对数阶O(nlogn)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( i &lt;= n)&#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上一段代码中，i 的取值为  2<sup>0</sup>， 2<sup>1</sup>， 2<sup>2</sup>，···· ， 2<sup>x-1</sup>， 2<sup>x</sup>  成等比队列。要想知道这段代码执行了多少次，求出 2<sup>x</sup> = n 的结果就行。 x = log<sub>2</sub>n，所以这段代码的时间复杂度就是 O( log<sub>2</sub>n)，这里忽视掉底数，那么所有的对数阶时间复杂度可以表示为O(logn)。</p>
</li>
<li><p><strong>O(m+n)、O(m * n)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> m , <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">int</span> sumOne = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;= m ; ++i)&#123;</span><br><span class="line">           sumOne += m;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">int</span> sumTwo = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;= n ; ++j)&#123;</span><br><span class="line">           sumTwo += j;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> sumOne+sumTwo;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，复杂度取决于两个数据规模 m 与 n，因此无法事先评估m 与 n 谁的量级更大,因此加法法则在这里不适用。因此上段代码的时间复杂度即为O(m+n)。但是乘法法则依旧适用：T1(m) x T2(n) = O(f(m) x f(n))。</p>
<p><strong>五、空间复杂度分析</strong></p>
<blockquote>
<p>空间复杂度就是<strong>渐进空间复杂度</strong>（asymptotic space complexity）,表示算法的存储空间与数据规模之间的增长关系。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initArray</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="number">1</span>   <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;= n ; ++i)&#123;</span><br><span class="line">           arr[i] = i * i;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，我们在第一行代码中申请了一个大小为n的int类型数组，除此之外其他的代码都没有占据更多的空间，因此整段代码的空间复杂度就是O(n)，相对于时间复杂度而言，空间复杂度的分析要更为简单。</p>
</li>
</ol>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

